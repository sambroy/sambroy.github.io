---
layout: post
title:  "Regexes for daily use"
date:   2020-03-01 18:30:15 -0800
categories: jekyll update
---
In this post, we are going to discuss some common code snippets used in extracting phrases out of text.
Alternative possibilities exist (for instance using spaCy and tokenization); for this post, we will be using the popular `re` package of Python.

### Comments
1. There is also this fantastic tool/site [regex101](https://regex101.com/){:target="_blank"} that is quite useful for
testing out one's regexes on sample strings, with explanations etc.
2. In the process of noting down my common regexes, I also came across this great resource:
[regular-expressions.info](https://www.regular-expressions.info/email.html){:target="_blank"} which has the same
purpose, to list out, as well as reason about the most commonly used regexes.
However the list below is tailored for my usecases, for my perusal during the day's work, so I am keeping this article in.

### Basics
There are four main functions in the [re module](https://github.com/python/cpython/blob/3.8/Lib/re.py){:target="_blank"}:
`match`, `search`, `findall` and `finditer` (there are many other interesting functions such as sub, subn - for
details look at the [source code](https://github.com/python/cpython/blob/3.8/Lib/re.py){:target="_blank"}).

The function `findall` gives
us all the matches of the _pattern_ in the actual _string_, but it is the function `finditer` that also gives us
the _spans_ of the matches. This is often necessary in actual work, where we want to modify the spans (say, we want
to create a HTML span where the span of the _pattern_ is highlighted).

Sample code snippets follow.

### Keyphrases
This is quite mundane, the only two things that need be noted here are:
1. use of the `\b` in order to demarcate word boundary.
2. How we frame the input keyphrase, which is often a variable in the program,
as a pattern - the use of `r'..`

{% highlight python %}
import re

def extract_kp_from_sentence(kp, sentence):
   pattern = r'\b' + kp + r'\b'
   for match in re.finditer(pattern, sentence):
   	  print(match.span())
{% endhighlight %}

A sample run:
{% highlight python %}
kp = "abc"
sentence = "This is the work of abc company"

extract_kp_from_sentence(kp, sentence)
# (20, 23)
assert(sentence[20:23] == 'abc')

sentence = "This is the work of abc & abc company"
extract_kp_from_sentence(kp, sentence)
# (20, 23)
# (26, 29)
{% endhighlight %}

If you want to ignore the case of the keyphrase while detecting a match, use `re.IGNORECASE`:
{% highlight python %}
kp = 'ABC'
sentence = "This is the work of abc & abc company"
list(re.finditer(pattern, sentence, re.IGNORECASE))
# returns
# [<re.Match object; span=(20, 23), match='abc'>,
# <re.Match object; span=(26, 29), match='abc'>]
{% endhighlight %}



### Emails
Here is a [regex](https://regex101.com/r/esfLe5/1){:target="_blank"} for emails; with the
username and the domain name separated out.
(Of course for the following examples, if we need to demarcate the word boundary, then
we should use `\b` before and after the base regex.)
{% highlight python %}
import re
email_pattern = r'(\w+)\@([\w+.]+)'

string = 'This is my email = abc@def.co.in'
matches = re.findall(email_pattern, string)
{% endhighlight %}

This results in the following:
{% highlight python %}
matches = [('abc', 'def.co.in')]
{% endhighlight %}

This is because of the grouping effected by `(..)`:
`(\w+)` for the first group and `([\w+.]+)` for the
second grouping.

If you want the entire email itself without the username and domain name separated,
then just remove the parentheses:
{% highlight python %}
import re
email_pattern = r'\w+\@[\w+.]+'
string = 'This is my email = abc@def.co.in'
matches = re.findall(email_pattern, string)

# which results in:
# matches = ['abc@def.co.in']
{% endhighlight %}

### GUIDs
Let us consider sample guids as generated by the [online guid generator](https://www.guidgenerator.com/){:target="_blank"}
Here is an example guid: `386940a3-f37d-48c4-b3a0-92ab6859e04c`
The structure of a guid is pretty clear; also refer to this [resource](https://docs.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid){:target="_blank"} for information. A guid string is composed of
- first 8 _hexadecimal_ digits,
- then three groups of 4 hexadecimal digits,
- and finally a group of 12 hexadecimal digits.

Crucial to note is that the parts are _hexadecimal_ digits, and not just arbitrarily alphanumeric.
We can catch _hexadecimal_ with `[0-9a-f]`.

A sample on regex101 is [here](https://regex101.com/r/esfLe5/2/){:target="_blank"}.
{% highlight python %}
import re
guid_pattern = r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
string = 'Here is a sample guid = 386940a3-f37d-48c4-b3a0-92ab6859e04c'
matches = re.findall(guid_pattern, string)

# matches = ['386940a3-f37d-48c4-b3a0-92ab6859e04c']
{% endhighlight %}

Of course, it would be great to make this regex compact, without having to repeat the
`[a-f0-9]{4}-` block thrice.

### URLs


# References:
1. [Tutorial on regexes on google.developer.com](https://developers.google.com/edu/python/regular-expressions){:target="_blank"}
2. [Another tutorial on Python regexes](https://www.guru99.com/python-regular-expressions-complete-tutorial.html){:target="_blank"}
3. [A nice blog on Python regexes and use of regex101](https://mlwhiz.com/blog/2019/09/01/regex/?utm_campaign=the-ultimate-guide-to-using-the-python-regex-module){:target="_blank"}
